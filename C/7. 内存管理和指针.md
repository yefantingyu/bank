# 内存和内存地址

##### 内存可以分为物理存储空间和逻辑存储空间

* ##### 物理存储空间：内存条，RAM或者ROM芯片

* ##### 逻辑存储空间：对存储器编码的范围

  * ##### 编码：对每个物理存储单元（1个字节）分配一个编号

  * ##### 寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写







## 内存地址

##### 启动一个程序，系统会在内存中给每个程序分配一块内存空间

* ##### 32-bit 系统：最多4G：$2^{32}=2^{10}*2^{10}*2^{10}*2^2=4G$

* ##### 64-bit 系统：理论最多：$2^{64}=2^{34}*2^{30}=2^{34}G$

##### 这些空间是一个个字节组成的，每个字节都有一个地址编号

* ##### 其实这个内存是虚拟的（虚拟地址/逻辑地址），它会使用特定的方式映射到实际的物理内存上

* ##### 但是对我们来讲，我们只关注虚拟空间，并不关心其实际的物理储存形式

##### 虚拟内存中每个字节对应一个编码，这个内存编号称之为==内存地址==，也叫做==指针==。说白了这个地址指向了储存的值，可以通过指针获取这一块储存区域的值



## 指针和指针变量

##### 指针：内存单元的编号。指针的实质是地址，地址的就是指针

##### 指针变量：用来储存指针的变量（用来存地址的变量）

* ##### 32-bit 系统，地址空间是$0\~2^{32}-1$,有$2^{32}$个地址编号，因此要4B的变量储存

* ##### 64-bit系统，有$2^{64}$地址编号，因此要8B的变量储存



# 指针

##### 指针式可以操作软件，硬件，内存等等

##### 指针也是一种数据类型，指针变量也是一种变量

##### 指针要存谁的地址，就定义成这个类型的指针：

* ##### 比如定义数组指针，就定义int  (*p)[10]

##### 指针变量指向谁，就把谁的==地址赋值==给指针变量。什么类型的指针就是保存什么类型的地址

##### 指针变量保存谁的地址，就指向谁。指向就可以操作这块内存空间.

##### *p在使用的时候，代表指针p指针所指向区域的内容

##### 排除定义的时候使用的时候，对表达式加一个*，就会减一级\*，而对表达式取&，就会加一级\*

&*p = p  

##### 指针赋值的的时候类型一定要匹配才能赋值，不然会报错

* ##### 这个不是说int赋值给int*是怎么样的，赋值一定要赋值定义过的，就不能把地址直接付给指针

* 不报错，但是不合法  int*p=2 野指针，不报错，但是不合法

```C
int a = 10;
int *p;
p = &a;    等号两端的类型必须匹配，P是一个*，因此右边也要带个*，因此加&
*p = 100； p加个*，数据类型减少了*，变成了int型，所以右侧也要是int型
    
int *p
int** q;  q = &p   类型是合法的，因为左右两端都是int**
*q = p:合法， 两侧都是int*
    
    
不合法：赋值要赋系统定义过的合法元素，即使你自己写一个正确的地址，因为系统没有定义过，他还是不合法的
    
int n=2; *p=&n *q = p;   最后一步是值赋值pq都存的n的地址，都指向它
p = q q存的地址赋给p，两个还是指向n
```



```C
int *p;// p 是指针变量，其数据类型是int *，也就是指针类型
int **p// p 是指针变量，其数据类型是int**，它是指针类型
int a=125;
p = &p;
如果要定义一个数组指针
int b[10];
int (*d)[10];
d = &b;

*p = 100 //指针p指向空间内容，并赋值成100
    
    
int b = 300;
p = &b// 把一块区域的地址赋值给一个指针，那么这个指针的指向就被改变了。
```

\&可以取变量在内存中的地址，$\color{red}{但是不能取寄存器变量，因为寄存器变量不在内存中，而在CPU里面，它是没地址的}$

地址的定义是内存中某个单元的编号

##### 通过指针修改变量的值

```C
int a = 0;
int b = 11;
int *p = &a;

*p = 100;
printf("a = %d, *p = %d\n", a, *p);

p = &b;
*p = 22;
printf("b = %d, *p = %d\n", b, *p);

```

## 指针的大小

##### 指针的大小和数据类型无关，因为它保存的是它指向空间的地址，地址长度和系统位数有关系

* ##### 32-bit 系统，地址长度都是4B

* ##### 64-bit系统，地址长度都是8B

```C

int *p1;
int **p2;
char *p3;
char **p4;
printf("sizeof(p1) = %d\n", sizeof(p1));
printf("sizeof(p2) = %d\n", sizeof(p2));
printf("sizeof(p3) = %d\n", sizeof(p3));
printf("sizeof(p4) = %d\n", sizeof(p4));
printf("sizeof(double *) = %d\n", sizeof(double *));

```

通过&取指针变量所指向空间内容时，取的内存的宽度（也叫做指针宽度）和指针变量本身的类型有关

指针宽度 == 指针的步长：指针加一过多少个字节

* char p1 取一个字节
* short *p2 取2个字节
* int *p3: 取三个字节
* int**p4: sizeof(int\*) 4个字节

```C
int num = 0x12345678;
char *p1 = (char*)&num;
short *p2 = (short*)&num;
int *p3 = &num;

printf("%x\n",*p1); //78
printf("%x\n",*p2); //5678
printf("%x\n",*p3); 12345678
 
printf("%p\n",p1);
printf("%p\n",p2);
printf("%p\n",p3);
printf("%p\n",p1+1);// 地址跳过了1个字节
printf("%p\n",p2+1);// 地址跳过了2个字节
printf("%p\n",p3+1);// 地址跳过了4个字节
0061FF10
0061FF10
0061FF10
0061FF11    
0061FF12
0061FF14
```



## 野指针和空指针

##### 野指针：没有被初始化的指针，或者被任意赋值的指针。

* ##### 指针的指向是随机的，不可以操作野指针

* ##### 指针p保存的地址必须是定义过的，向系统申请过的，不能人为的写

##### 指针变量可以被任意类型赋值，只要不越界。带式任意数值赋给指针变量没有意义，因为指向了一个未知的区域；

##### 操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

```C
int a = 100;
int *p;
p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义

p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义

*p = 1000;  //操作野指针指向未知区域，内存出问题，err
printf("%d",*p);  //操作野指针指向未知区域，内存出问题，err
```

C语言NULL的值就是0，就是0x0000 0000 

##### 空指针：将指针的值赋值为0. 指针p的内容赋值为0

```C
int *p=NULL;
```

```C
int *p = NULL;
*p = 200;
printf("%d",*p);//它干的事情是把０地址的那个值改成２００，但是，这是不合法的，因为０地址是系统占用，不能修改
```

##### 既然不能用,为什么要复制成NULL: 它只是一个标记,这个标记是可以被捕获的

* ##### 无论是用之前还是用之后,都要习惯性的把值赋值成NULL

* ##### 使用的时候,可以使用NULL来判断这个指针有没有被使用

```C
p!=NULL
```



## 万能指针 void*

void *指针可以指向任意变量的内存空间：

不可以定义void类型的的变量,因为编译器不知道给变量分配多大空间

但是可以定义void*类型,因为指针都是4个字节

如果要对void指针进行操作,必须转化成要使用的指针类型;

```C
void *p =NULL;
int a = 10;
p = (void*)&a;
printf("%d",*p)// 报错
为什么:取值的时候和指针的步长有关系: sizeof(void) 注意void的长度是0,不知道几个字节,无法进行取值.
因此使用的时候要转成使用的类型,才知道取几个字节
printf("%d\n",*(int *)p);// p转成int类型

*(int *)p =11
```



## const 修饰的指针变量

##### const用于规定哪些东西不能被修改

```C
const int a = 10; // 修饰变量a,不能再通过a修改a的内存的内容,可以通过地址修改
int *p = &a;
*p = 100; //通过指针修改了a的值
```

```C
int a=10;
int const *p1 = &a;
const int *p = &a;// const这里修饰的是指针       不能通过*p修改p所指向的内容
//*p =100 error: 不能通过*p修改p所指向的内容---不能修改,但是能通过*p进行访问
p1 =&b  但是能更改指向

int * const p=&a;//cosnt 修饰的是变量p, p保存的地址不可以修改,p里面的地址值不能被改变,也就是不能更改指向
//p = &b: error  不能更爱指向
*p2 = 222; //ok 但是能更改指针指向的值

const int *const p = &a; // 指向a的指针,既不能改变,也不能通过指针改变a的值
```



## 多级指针

##### 只要变量带*,这个变量就是个指针变量--

##### int **k 那它的类型就是int\*\*

```C
int a = 10;
int a = 10;
int *p = &a; //一级指针
*p = 100; //*p就是a

int **q = &p;
//*q就是p,也就是a的地址
//**q就是a,也就是a的值

int ***t = &q;// 按照一个一个&多加一个*的原则,q是int**类型,两边都是int ***类型
//*t就是q
//**t就是p
//***t就是a



```



## 指针和数组

##### 数组名:首元素的地址,他是一个常量不能被修改

因为数组上的元素是连续的,故可以通过一个位置指针加减访问其他位置上的值

要想得到数据,先要得到数据的地址*p就是获取地址背后的内容

注意*(p+1)是地址加以 *p是获取值之后加1

```C
int a[] = {1,2,3,4,5,6};
a = 10// err: 因为数组名是个常量,常量不能被修改
    
*(a+3) = 3;
a 获取0位置上的地址
a + 1 获取的是1位置上的地址
a + n就是获取n位置上的地址
    int i = 0;
int n = sizeof(a) / sizeof(a[0]);

for (i = 0; i < n; i++)
{
    //printf("%d, ", a[i]);
    printf("%d, ", *(a+i));
}
printf("\n");

int *p = a// a等价于&a[0]   
printf("%d, ", *(p+1));
int *t = &a[5] //取5位置上的地址
printf("%d, ", *(p-2));

*(t-2)=3


```

```C
int a[5]={1, 2, 3, 4,5};
int *ptr =(int *)(&a + 1);
printf("%d %d",*(a+1),*(ptr-1));  2  5
&(a + 1) 注意&a表示数组地址,+1就跑到了数组外边界加1的位置上了.&a-1正好是最后一个元素地址
&a 是元素地址,加一就是索引为1的位置,因此 2 5
```



## 指针加减运算

##### C语言中两个指针相加没有意义，相减有一定的意义。

##### 指针之间相减一定是同类型，如果类型不同，不能相减

##### 两个同类型指针相减表示中间跨过多少个元素。

 ```C
 int a[10]={1, 2, 3, 4,5,6,7,8,9};
 int *p = a;
 // 为什么要转成int*呢    其实不转的画指针是int[10]类型的指针，依次跨国一个数组，转成int*一次跨过一个元素
 int *q =(int *)(&a+1)-1;  //&a[9]
 printf("%d\n",q-p); //9  p+9 =q
 printf("%d\n",*(p+3))//4
 printf("%d"\n,p+q);// C语言中两指针相加没有意义
 ```

##### 指针计算不是简单的整数相加

##### 如果一个int*+1，结果增加一个int大小

##### 如果是一个char*+1 结果增加一个char大小

##### 如果是一个int[5]指针，结果增加一个长度5的数组大小

```C
int a;
int *p = &a;
printf("%d\n", p);
p += 2;//移动了2个int
printf("%d\n", p);

char b = 0;
char *p1 = &b;
printf("%d\n", p1);
p1 += 2;//移动了2个char
printf("%d\n", p1);

// 指针变化操作数组
int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int i = 0;
int n = sizeof(a) / sizeof(a[0]);

int *p = a;
for (i = 0; i < n; i++)
{
    printf("%d, ", *p);
    p++;
}

```

##### 减法

##### 和加法类似。两个同类型指针相加返回的是之间相隔几个元素。索引m和索引n之间隔了m-n个元素

```C
int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int *p2 = &a[2]; //第2个元素地址
int *p1 = &a[1]; //第1个元素地址
printf("p1 = %p, p2 = %p\n", p1, p2);

int n1 = p2 - p1; //n1 = 1   //指针直接加减返回的是中间相隔几个元素
int n2 = (int)p2 - (int)p1; //n2 = 4  //都转成整型就是中间地址相隔几个字节了
printf("n1 = %d, n2 = %d\n", n1, n2);

```



## []不是数组的专属

##### [] 等价于*（）

##### [0]等价于*(p+0)

```C
int a = 10;
int *p = &a;
p[0] = 100;
printf("a=%d\n"); //a = 100 说明p操作的是a元素

int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int i = 0;
int n = sizeof(a) / sizeof(a[0]);

int *p = a;
for (i = 0; i < n; i++)
{
    printf("%d, ", p[i]); == printf("%d, ", *(p+i));
}

```

### 指针数组

##### 指针数组数组里面每一个元素都是一个指针

```C
//指针数组
int a = 1;
int b = 2;
int c = 3;
int*num[3] = {&a,&b,&c};
printf("%d",*num[0]);  
// 分析一下为什么不是*num呢，num是首元素的地址，也就是&num[0],我们要的是num[0]

//定义一个指针保存首元素地址
int **p = num
int a = **p;// 取a的值
int b  = **(p+1)

```

# 指针和函数

## 函数形参改变实参的值

函数的值总是单项传递。传递地址后，其实操作就是对地址进行操作了

指针作为形参，可以改变实参的值

```C
void swap1(int x, int y)
{
	int tmp;
	tmp = x;
	x = y;
	y = tmp;
	printf("x = %d, y = %d\n", x, y);
}

void swap2(int *x, int *y)
{
	int tmp;
	tmp = *x;
	*x = *y;
	*y = tmp;
}

int a = 3;
int b = 5;
swap1(a, b); //值传递
printf("a = %d, b = %d\n", a, b);// 值没有改变，因为传递的是值，

a = 3;
b = 5;
swap2(&a, &b); //地址传递
printf("a2 = %d, b2 = %d\n", a, b);// 值被换了
```

### 数组名做函数参数

数组的操作只要直到首元素地址，就可以直接操作了

##### 数组作为函数的形参，会自动退化为指针。

##### 不同的函数享受不同的栈空间，因此不传数组元素值，只传个指针，函数外肯定不知道你这个数组有几个元素的。想要对整个数组操作，还是要传递数组长度的



##### 为什么会出现下面的情况：

##### 数组名，首元素地址：这个地址是int*类型。

##### 数组作为函数的形参，会自动退化为指针 

* ##### int b[10]其实相当于*b

* ##### int b[\][\]就是**b。有几个【】就是几个指针

```C
void print_a(int b[10]){
    for(int i=0;i<sizeof(b)/sizeof(b[0]);i++){
        printf("%d",b[i]);
    }
}
int a[10]={1,2,3,4,5};
print_a(a); //1

sizeof(b)就相当于问sizeof(int *)=4
sizeof(b[0])本质就是 sizeof(*(b+0))=sizeof(1)=4 所以只打印了一个
```

##### 既然写不写都要退化，直接写指针吧，而且还要传递数组长度

```C
void printArrary(int *a, int n)   也可以定义为(int a[],int n)效果一样，但是明显点
{
	int i = 0;
	for (i = 0; i < n; i++)
	{
		printf("%d, ", a[i]);
	}
	printf("\n");
}

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int n = sizeof(a) / sizeof(a[0]);

	//数组名做函数参数
	printArrary(a, n); 
	return 0;
}
```

### 指针作为函数的返回值

```C
int * getnum(){
    int num = 5;
    return &num;
}
int *p = getnum();
printf("%d",*p);//不能这么干
```

##### 一切看起来都很合理，但是注意，函数的内存在使用过后就会被销毁，也就是*p指向的空间不存在了。

##### {}中定义的变量是局部变量，局部变量在函数结束后，空间会被释放

##### 在函数外部定义的变量叫全局变量，整个项目都可以使用。在程序开始时候开辟空间，在程序结束的时候释放空间

```C
int a = 10;
int *getA()
{
	return &a;
}
int main()
{
	*( getA() ) = 111;
	printf("a = %d\n", a);

	return 0;
}
```



p+5走5步，数组也相当于走5步



## 例题

```C
int a[10]={1,2,3,4,5,6,7,8,9,10}
int *p=&a[3];
int b = p[5]
p-----4
注意有数组按照数组来，没有数组 p[5]=*(p+5)=9
```

```C
funa(int *x,int*y){
    int *p;
    *p = *x;
    *x = *y
    *y = *p
}
上面的是错的，注意*p没有指向一个合理的位置就开始赋值了：野指针，错误
 funa(int *x,int*y){
    int p;
    p = *x;
    *x = *y
    *y = p
}  正常是这样的
```



有一个数组，找出第二大的数，并打印出来，使用*操作数组元素个数，不使用[],不使用冒泡排序。

```C
int a[] = {100,1000,100,234,123,500,32,68,41,99,13,71}
```







## const 修饰的指针变量



##### 1. const variable 该变量值不能被直接修改，但是能被指针间接的修改

```C
const int a = 10;
//a = 100; //err
int *p = &a;
*p = 15;// 修改完成
```

##### 2. const char * / char const * + variable 修饰的都是指针指向的内存。指针指向的内存的内容不能变，但是指向可以变. 

```C
char buf[] = "aklgjdlsgjlkds";
const char *p = buf;
p[1] = '2'; //err;
char buf2[] = "aklgjdlsgjlkdweqws";
p = buf2; // yes
```

##### 3. char * const variable. 修饰的是指针变量，指针指向不能变，但是指向的区域的内容可以变

```C
char buf[] = "aklgjdlsgjlkds";
char * const p2 = buf;
p2[1] = '3';
//p2 = "salkjgldsjaglk"; //err

```

##### 4. const char * const p3  完全锁住，指向，指向内存的内容都不能变化



## 例题：

##### strlen: ‘\0’ ？？

##### char *p1,p2 p1 是char\* p2 是char类型   char *p1，\*p2 两个都是指针



数字常量不能被取地址

```C
int i=0;
int *p = &i; 正确
int *p = &(i+1)错误，这不是指针运算，同时不是字符串的常量取地址是错误的
说到底字符串有文字常量区，但是实型和整型没有
```





```C
char s[10];
s = "abcdefg"; 不行，为什么：s是个常量，不能被赋值
```



```C
char a[5]="",*p=a;
A p = "abcd"; 是可以的，字符串会存在字符常量池中，p存储的是字符串的首地址，和a没有关系
B *p = “abcd”这个不可以，但是最容以错，p保存的是首元素地址，取*就是数组首元素，数组首元素不能存地址，因此不对
C *a = "abcd" 不对：a保存的是首元素地址，取*就是数组首元素，数组首元素不能存地址，因此不a

```

```C
char *s[]="abcdef";
如果p1 在a p2 =(char *)(&s+1)
p2-p1 如果看不出来，直接相当于在字符串后加了'\0'然后在加一，p1相当于索引0，p2相当于7，相减为7
```

```C
void fun(char s1[]){
    int i,j;
    for(i=j=0;*(s1+i)!='\0';i++){
        if(*(s1+i)<'n'){
            *(s1+j) = *(s1+j);
            j++;
        }
    }
    *(s1+j)='\0';
}
main(){
    char str[] = "morning",*p;
    p = str;
    fun(p);
    puts(p); //mig
}
做这样的题，注意下面这种思考方式比较好，一步一步推导
迭代次数  判断    值变化
1    s[0]<n    s1[0] = s1[0] j=1,i=1  这么推导
2    s[1]>n   j=0,i=1
```



```C
// 两个字符串拼接的实现
char* concat(char* str1, char* str2){
    char* p1=str1;
    char* p2=str2;
    while(*p1!=0){
        p1++; // 找到str1的末尾
    }
    while(*p2!=0){
        *p1 = *p2;
        p1++;
        p2++;
    }
    *p1 = '\0';
    return p1;
}
```

```C
int a=1,b=2,c=3;
c = func(a,&b);
b = func(c,&a);
a = func(b,&c);

int func(int a, int *p){
    a++;
    *p = a + 2;
    return (*p+a);
}
考函数，这个解决方法是，把变量名重的换掉,化简算式，有指针的直接带入，防止出错
h++ *p = h + 2  
*p= h+3
return *p+h = 2h + 4
a = 1 b =2 c = 3
num1: h = 1, b = 4, c = 6
num2: h = 6, a = 9, b = 16
num3: h= 16; c = 19, a = 36
```

```C
int a[10] = {1,4,7,2,8,1,3};
int *p = a;
printf("%d\n",(*p)++);1---- 1 *p *p = *p + 1
printf("%d\n",*(p++));2-----2 *p p++
printf("%d\n",*p++);4---先p++ 然后*
printf("%d\n",*p);7---先p++ 然后*  
注意第一个，++在后 先操作再自加，因此，输出1，然后数组第一个元素变成2
第二个，括号并不能影响++的运算，仍旧是先取地址，输出2，然后自加
不管加不加括号，先要取值，先要*p，然后进行加加操作，判断是*p = *p +1 还是 *p， p = p + 1
```

