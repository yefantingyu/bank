# 内存管理

##### 生命周期：开辟空间：出生， 释放空间：死亡，这个开辟到释放的过程，生命周期

## 1. 作用域

##### 作用域：变量起作用的范围

##### C语言的作用域有三种：

* ##### 代码块作用域：代码块{ }之间的代码

* ##### 函数作用域: 变量仅仅作用于当前函数中

* ##### 文件作用域：定义在函数之外的变量

  * ##### 全局变量，```#include <stdio.h>```

## 2. 变量类型

##### 局部变量 + 静态局部变量 + 全局变量 + 静态全局变量

##### 看一个变量看几个要素：==作用域== + ==生命周期== + ==未初始化的值==

#### 2.1 局部变量 / ==auto自动变量==

##### 代码块{}内部定义的变量就是局部变量，又叫做自动变量。 auto可写可不写

```C
auto int b;
```

##### 作用域：在函数内定义，就只在函数范围内有效；在复合语句（就是{}包含多条语句）种定义，就只在符合语句中有效。总的来说。在{ } 包含内定义，就只在{ } 有效，出了就不好使了

* ##### 比如b 可在if内部使用，因为他们都算main的函数范围内，而c在代码块内作用，出了代码块就不好使了

##### 生命周期：函数的调用，或者复合语句开始执行开辟空间，函数结束或者复合语句执行结束释放空间。

##### 初始化：如果没有赋初值，内容为随机

```C
void test()
{
	//auto写不写是一样的
	//auto只能出现在{}内部
	auto int a = 10; 
}
int main(void)
{
	int b = 10;
	if (1)
	{
		//在复合语句中定义，只在复合语句中有效
		int c = 10;
		printf("a = %d\n", c);
	}
	//c = 10; //err离开if()的复合语句，a已经不存
	return 0;
}
```

#### 静态局部变量

##### 代码块{}内部定义的变量，并且加上static修饰符

##### 初始化：未初始化，系统自动赋值，数值型自动赋值0，字符型赋空字符

##### 作用域：和局部变量完全相同，只能在函数内或者复合函数内部使用

##### 生命周期：静态局部变量生命周期和==程序运行周期==相同，$\color{red}{在main函数运行之前开辟空间}$, main函数程序结束的时候才释放空间。

* ##### 只初始化一次，但可以赋值多次，值会动态变化

* ##### 甚至可以传递其指针对值进行操作

* ##### 就是作用域限制在函数或者符合函数内部，外面不能直接访问它的名字

##### 其实能不能操作主要看那个函数生命周期停止了那块区域有没有被释放，如果被释放了，就不能直接操作，否则是可以操作的

```C
#include <stdio.h>
int * fun2()
{
	//静态局部变量，没有赋值，系统赋值为0，而且只会初始化一次
	static int a;
	a++;
	printf("a = %d\n", a);
    return &a;
}

int main(int argc, char *argv[])
{
	fun2();
	fun2();
	fun2();
	fun2();

    // 对静态是可以操作值的
    int *p = fun2();
    *p = 125;
    printf("%d\n",*p);

}
```

#### 全局变量

##### 作用域：在函数外定义，可被所有文件中的函数所共用，若其它文件中的函数调用此变量,须用extern声明

* ##### 不同文件的全局变量不可重名

##### 初始化：未初始化，系统自动赋值，数值型自动赋值0，字符型赋空字符

##### 生命周期：静态局部变量生命周期和==程序运行周期==相同，$\color{red}{在main函数运行之前开辟空间}$, main函数程序结束的时候才释放空间。

##### 缺点：占据空间，不释放

```C
int c; c// 全局变量
int main(){
    c = 12;
}
```

#### extern全局变量声明

##### extern int a; 声明一个变量，这个全局变量在别的文件中已经定义了，这里只是声明，而不是定义。

```C
extern int num32
void fun3{
    num32 =13212;
} 
```

#### 静态全局变量

##### 在函数外定义的，并且加上static修饰的变量

##### 作用域：在函数外定义,作用范围被限制在所定义的文件中，只能使用在==当前文件==中

* ##### 不同文件静态全局变量可以重名, 作用域不冲突，自己在自己的文件中使用

* ##### 静态全局变量==不能声明（不能用于extern），也不能在其他文件中使用

##### 初始化：未初始化，系统自动赋值，数值型自动赋值0，字符型赋空字符

```C
static int c; c// 静态全局变量
extern static int abc: // 报错，静态变量不能声明，更不可能在别的文件用了
int main(){
    
}
```

#### 总结

作用域：局部变量都是在函数内或者复合语句内，全局变量作用域所有文件，静态局部变量作用于当前文件内部。

生命周期：只要是静态，或者全局：生命周期：静态局部变量生命周期和==程序运行周期==相同，$\color{red}{在main函数运行之前开辟空间}$, main函数程序结束的时候才释放空间。普通：函数开始开辟空间，函数结束释放空间

初始化：局部：随机，其他未初始化，系统自动赋值，数值型自动赋值0，字符型赋空字符









# 内存操作函数

## 1. 堆区内存分配和释放

### malloc

```C
#include <stdlib.h>
void *malloc(size_t size);
```

##### 在内存的动态存储区(堆区)中分配一块长度为size字节的==连续==的区域。但是这个空间内部的内容是随机的，一般用memset初始化

##### 参数：size：需要分配内存大小(单位：字节)

##### 返回值：

* ##### 成功：分配空间的起始地址，返回类型为void*，需要转换成你需要的类型

* ##### 失败：NULL

```C

// 申请int类型的空间
int *number = (int *)malloc(sizeof(int));
//申请一个数组，数组有10个元素
int *array = (int *)malloc(10*sizeof(int)));
// 检验malloc 是否成功
if (array == NULL)
{
    printf("申请空间失败!\n");
}
// 清零
memset(array,0,10);
//释放
free(array);


```

#### free()

```C
#include <stdlib.h>
void free(void *ptr);
```

##### 功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。==对同一内存空间多次释放会出错==。

##### 参数：ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。不是malloc的别用free释放。free只能用来释放由malloc开辟的堆空间

##### 返回值：无

```C
int *array = (int *)malloc(10*sizeof(int)));
free(array+1)// 不行，系统记录了从哪里开辟的空间，开辟多少就要释放多少，不能随意规定从哪里释放
```

