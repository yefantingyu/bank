

Visual

语言里面有个框架管理器，#1可以输入一个框架，自己搭建一个框架



如果建立了多个项目，右键解决方案，通用属性----启动项目-----当前选定内容：激活哪个文件，就执行哪个项目







# C的进制

整数越位的例题:  

```C
char ch = 0x82;
printf("%d\n",ch); //-2
0x82 = 1000 0010(补码) 计算机中存储的就是1000 0010
printf要的是原码, 因此转化成原码 11111110 =-(2^7 -1 -1) =- 126
    
int num = 0x80000001;
printf("%d\n",num); // -2147483647
1. 先判断越位与否: 4* =32, 最高位不能是1, 肯定越位了
2. 十六进制, 储存的是补码  1000 000- 01
3. 十进制输出, 要的是原码, 转换 1111--1111, 32个1, 数据为 31位 于是等于 -(2^31-1)
    
char ch = -123
printf("%d\n",num); 
1. 不越位,因此输出 -123
    
int num = 0xffffffff
printf("%d\n",num);//-1
1. 越位 1111 1111-- 1111
2. 补码就是 1111   
3. 求原码, 100 --- 1   结果 -1

char num = 129;
printf("%d",num);  结果: -127
1. 越位 1000 0001   转换的时候不要犯错误:是正常转化为2进制,不是计算机中怎么储存的
2. 十进制赋值的是原码, 正数原码等于补码,于是储存的时候村的就是1000 0001
3. printf要的是原码, 但他发现1开头是负数,于是要转换成原码, 于是计算机中1111 1111 = -127
    
    
unsigned int num = 0xffffffff  不越界,打印正常, 因为无符号全是数据位
    

```



## 变量



##### 打印格式:

| 打印格式 | 含义                        |
| -------- | --------------------------- |
| %d       | 输出一个有符号的10进制整型  |
| %o       | 输出一个有符号的八进制整型  |
| %x       | 输出一个16进制,字母小写输出 |
| %X       | 输出一个16进制,字母大写输出 |
|%u|输出一个10进制无符号数|

##### 整型输入

scanf() 从键盘(标准输入) 读取数据

```C
//不要加“\n”
scanf("%d", &a);

```



## sizeof

##### 

```C
int a;
int b = sizeof(a);//sizeof得到指定值占用内存的大小，单位：字节
printf("b = %d\n", b);

size_t c = sizeof(a);
printf("c = %u\n", c);//用无符号数的方式输出c的值
```

```C
char a;
short b;
int c;
long d;
long long e;
int length = sizeof(a);
int length2 = sizeof(int);// 也是可以的

printf("%d\n",sizeof(a));
printf("%d\n",sizeof(b));
printf("%d\n",sizeof(c));
printf("%d\n",sizeof(d));
printf("%d\n",sizeof(e));
```

## 整型变量

| 类型           | 空间                             |
| -------------- | -------------------------------- |
| char(最小整形) | 1B                               |
| short(短整型)  | 2B                               |
| int(整型)      | 4B                               |
| long（长整型） | windows 4B Linux 32位 4B 64位 8B |
|long long(长长整形)|8B|

##### 注意， short 可以写成 short int， long 可以写成long int

##### 整型数据在内存中占的字节数与所选择的操作系统有关。虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型

##### 当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能==丢失高位==。

```
short a = 10;
```

##### 如果什么也不写默认int类型， 它经历了先把int转化为short， 然后赋值给short。

##### 先转换，再赋值=> ==隐式转换==



##### 整数类型

##### 如果什么符号不加，默认整型，加了就代表固定类型

| **整型常量** | **所需类型**               |
| ------------ | -------------------------- |
| 10           | 代表int类型                |
| 10l, 10L     | 代表long类型               |
| 10ll, 10LL   | 代表long long类型          |
| 10u, 10U     | 代表unsigned int类型       |
| 10ul, 10UL   | 代表unsigned long类型      |
| 10ull, 10ULL | 代表unsigned long long类型 |

| **打印格式** | **含义**                   |
| ------------ | -------------------------- |
| %hd          | 输出short类型              |
| %d           | 输出int类型                |
| %ld          | 输出long类型               |
| %lld         | 输出long long类型          |
| %hu          | 输出unsigned short类型     |
| %u           | 输出unsigned int类型       |
| %lu          | 输出unsigned long类型      |
| %llu         | 输出unsigned long long类型 |

```C
short a = 10;
int b = 10;
long c = 10l; //或者10L
long long d = 10ll; //或者10LL

printf("unsigned short a = %hu\n", a2);
printf("unsigned int b = %u\n", b2);
printf("unsigned long c = %lu\n", c2);
printf("unsigned long long d = %llu\n", d2);

```



### 从键盘上读取字符

```C
char ch;
scanf("%c",&ch); // 读取一个字符
```

做个小测试

```C
char ch;
char ch2;
scanf("%c",&ch);
scanf("%c",&ch2);
printf("ch=%c\n",ch);
printf("ch2=%c\n",ch2);
如果你输入的是 a c     那么输出值是 ch=a  ch2=, 其实空格被输入了
这种读取方式不能略去空格和回车。如果你只输入a然后回车， ch2 值为回车
    
只有输入时ac， 才正确读取两个字符。因为%c是一个字符一个字符读取的，理解以下
```





## 转义字符

有特殊含义的字符

实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中， 浮点型变量分为两种： 单精度浮点数(float)4B、 双精度浮点数(double)8B， 但是double型变量所表示的浮点数比 float 型变量更精确。

由于浮点型变量是由有限的存储单元组成的，因此只能提供有限的有效数字。在有效位以外的数字将被舍去，这样可能会产生一些误差。

不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型。

```C
#include <stdio.h>

int main()
{
	//传统方式赋值
	float a = 3.14f; //或3.14F
	double b = 3.14;

	printf("a = %f\n", a);
	printf("b = %lf\n", b);

	//科学法赋值
	a = 3.2e3f; //3.2*1000 = 3200，e可以写E
	printf("a1 = %f\n", a);

	a = 100e-3f; //100*0.001 = 0.1
	printf("a2 = %f\n", a);

	a = 3.1415926f;
	printf("a3 = %f\n", a); //结果为3.141593

	return 0;
}

```

##### 打印时默认输出6位小数点

* float 类型只能保证7位精度(整数+小数)
* double 类型只能保证15位精度
* 输出几个小数点.nf

一般存小数可以用double存，因为精度更高

```C
float a = 3.1415926456;
double b = 3.1415926456;
printf("a=%.8f\n",a); //输出8位
printf("a=%.8lf\n",b); //输出8位
a=3.14159274
a=3.14159265
```



## 字符串常量

##### 1. 字符串常量是由==双引号==括起来的==字符序列==，如“china”、“C“

##### 2. 字符串在内存中是一段==连续的char空间==， 以'\0'结尾

* ##### 连续的char空间，相当于char数组

* ##### '\0' ASCII码为0。 它的作用就是标记，标记字符串的结束

* ##### 一般一个字符串字节数等于实际字符串加1，因为有\0。比如"abc"， 4个字节

```C
char[] str = "12312";
printf("%s",str);
```





printf



putchar: 输出一个char。要输出一个字符串只能用printf %s









## 格式输出

m.n格式：m宽度，n小数点个数

```
double a = 3.1415;
printf("%10.41f",a);

```



```C
int a =10;
prinf("%10d\n",a);   宽度为5位，不足的前面补空格
    prinf("%10-d\n",a);   宽度为5位，不足的前面补空格
    
    
    printf(%0-5d) 左对齐了补0没效果
```





## 练习

```C
char a = 'a';
printf("%d\n",sizeof(a));//1
printf("%d\n",sizeof('a'));//4 
printf("%d\n",sizeof("a"));//2
如果a， char类型，一个字节
sizeof'a' 字符型本质是ASCII码，相当于int 4B
字符串 一个字符还有末尾的'\0',因此2个字节

```

```C
printf("02d\n",12345); \\ 12345 数字本身就是5位，不可能占据2位，所以错误
```

```
int num1 = -10;
unsigned int num2 = 5;
printf("%u",num1+num2);
printf("%d",num1+num2);
num1 + num2 > 0?printf(">0\n"):printf("<0\n");
结果 4294967291      >0
要明确，unsigned int和int相加最后结果肯定是unsigned类型
num1 是 0000 0000 0000 0000 0000 0000 0000 1010
计算机中存它的补码 1111 1111 1111 1111 1111 1111 1111 0110
5无符号数 0000 0000 0000 0000 0000 0000 0000 0101
两个无符号数相加，结果为1111 1111 1111 1111 1111 1111 1111 1011
1. 最终的结果就应该是无符号的，因此肯定大于零
2. 这个无符号数是2^32-1-4= 4294967296-5 4294967291
3. 当然，你是可以把无符号转成有符号的，转成整型要的是原码，结果为负数，求原码
1000 0000 0000 0000 0000 0000 0000 0101   结果为-5


```



### 浮点型：注意

printf("%d",3.2) 结果不是3，而是其它类型的，因为浮点数遵循IEEE标准，它的储存和整型完全不一样，因此输出是不可控的

int a = 3.2;

printf("%d",a) 就是3， 因为发生了强制类型转换





C 的赋值：赋值符号=

a=b=c=d=e=5; 依据赋值运算符的右接合性

 e=5; d=e; c=d; b=c; a=b;

赋初值后的变量和其后的其它同类变量之间依然必须用逗号进行间隔，赋值语句则必须用分号进行收尾。 例如： int a=5,b,c;

不允许连续给多个变量赋初值。 像是下述说明就是错误的： int a=b=c=5 必须写成 int a=5,b=5,c=5;赋值语句允许连续赋值。
